//  boost.ai Android SDK
//  Copyright Â© 2021 boost.ai
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.
//
//  Please contact us at contact@boost.ai if you have any questions.
//

package no.boostai.sdk.ChatBackend.Objects

import kotlinx.serialization.*
import kotlinx.serialization.json.JsonElement

@Serializable
enum class Command {
    START,
    POST,
    DOWNLOAD,
    RESUME,
    DELETE,
    FEEDBACK,
    TYPING,
    POLL,
    POLLSTOP,
    STOP,
    LOGINEVENT,
    SMARTREPLY,
    HUMANCHATPOST,
    CONFIG
}

/**
Types a CommandPost can be

- text: message()
- trigger_action: triggerAction()
- action_link: actionButton()
- external_link: urlButton()
- feedback: feedback()
- files: sendFiles()
 */
@Serializable
enum class Type {
    @SerialName("text")
    TEXT,
    @SerialName("trigger_action")
    TRIGGER_ACTION,
    @SerialName("action_link")
    ACTION_LINK,
    @SerialName("external_link")
    EXTERNAL_LINK,
    @SerialName("feedback")
    FEEDBACK,
    @SerialName("files")
    FILES
}

@Serializable
data class Files (
    val files: List<File>
)

@Serializable
data class File (
    val filename: String,
    val mimeType: String,
    val url: String
)

/**
The types of feeback possible on an element

types can be: positive, removePositive, negative, removeNegative
 */
@Serializable
enum class FeedbackValue {
    @SerialName("positive")
    POSITIVE,
    @SerialName("remove-positive")
    REMOVE_POSITIVE,
    @SerialName("negative")
    NEGATIVE,
    @SerialName("remove-negative")
    REMOVE_NEGATIVE
}

@Serializable
data class ConversationFeedback (
    val rating: Int,
    val text: String?
)

@Serializable
sealed class ICommand {
    @Required
    abstract val command: Command
}

@Serializable
sealed class IConversation : ICommand() {
    /// Identifies the conversation. The conversation id is generated by the API. The SDK will pick up the conversationID for you,
    /// but if you store the conversationId for later usage (e.g. restart of app) you need to set this manually and not use CommandStart
    @SerialName("conversation_id")
    var conversationId: String? = null

    /// Identifies an authenticated user
    @SerialName("user_token")
    var userToken: String? = null
}

@Serializable
class CommandConfig : ICommand {
    constructor(vanId: Int? = null) {
        this.vanId = vanId
    }

    @Required
    override val command: Command = Command.CONFIG

    @SerialName("van_id")
    var vanId: Int? = null
}

/**
Starting a conversation

You initiate a conversation by calling CommandStart.
The simples form of the command is without parameters
 */
@Serializable
class CommandStart : ICommand {
    constructor(
        userToken: String? = null,
        language: String? = null,
        filterValues: List<String>? = null,
        contextIntentId: Int? = null,
        triggerAction: Int? = null,
        authTriggerAction: Int? = null,
        skill: String? = null,
        clean: Boolean? = null,
        clientTimezone: String? = null,
        customPayload: String? = null,
        preferredClientLanguage: List<String>? = null
    ) {
        this.userToken = userToken
        this.language = language
        this.filterValues = filterValues
        this.contextIntentId = contextIntentId
        this.triggerAction = triggerAction
        this.authTriggerAction = authTriggerAction
        this.skill = skill
        this.clean = clean
        this.clientTimezone = clientTimezone
        this.customPayload = customPayload
        this.preferredClientLanguage = preferredClientLanguage
    }

    @Required
    override var command = Command.START

    /// BCP47 code string. Examples 'en-US', 'fr-FR' and 'sv-SE'. This will cause the VA to respond in the specified language
    var language: String? = null

    /// List of strings, e.g. ['login', 'production']. Filter values are used to filter actions in the action flow
    @SerialName("filter_values")
    var filterValues: List<String>? = null

    /// Itent Id to set conversation in a specific context
    @SerialName("context_intent_id")
    var contextIntentId: Int? = null

    /// Specific aciton id you want to trigger instead of the welcome message configured in Settings -> System action Triggers. If you have enabled consent
    /// this parameter will return an error message
    @SerialName("trigger_action")
    var triggerAction: Int? = null

    /// Specific action id you want to trigger for authenticated users instead of the welcome message configured in Settings -> System action Triggers.
    /// If you have enabled consent this parameter will return an error message.
    @SerialName("auth_trigger_action")
    var authTriggerAction: Int? = null

    /// Identifies an authenticated user
    @SerialName("user_token")
    var userToken: String? = null

    /// Sets the Human Chat skill for the conversation
    var skill: String? = null

    /// Return clean text
    var clean: Boolean? = null

    /// Forwarded to the API Connector and External API's. This parameter can tell an API which timezone the client is currently in.
    /// The format is listed [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
    /// Use the column TZ database name from the list.
    @SerialName("client_timezone")
    var clientTimezone: String? = null

    /// List of preferred client languages, in BCP47 format
    @SerialName("preferred_client_language")
    var preferredClientLanguage: List<String>? = null

    /// A string that is forwarded to External API's on each request
    @SerialName("custom_payload")
    var customPayload: String? = null
}

/**
Posting data

When you have obtained a conversationID with CommandStart, you can post data to the server
 */
@Serializable
class CommandPost : IConversation {
    constructor(
        conversationId: String?,
        userToken: String?,
        type: Type,
        clean: Boolean? = null,
        filterValues: List<String>? = null,
        contextIntentId: Int? = null,
        skill: String? = null,
        id: String? = null,
        customPayload: String? = null,
        clientTimezone: String? = null
    ) {
        this.conversationId = if (userToken == null) conversationId else null
        this.userToken = userToken
        this.type = type
        this.clean = clean
        this.filterValues = filterValues
        this.contextIntentId = contextIntentId
        this.skill = skill
        this.id = id
        this.customPayload = customPayload
        this.clientTimezone = clientTimezone
    }

    @Required
    override val command: Command = Command.POST
    
    @Required
    var value: JsonElement? = null

    /// Type of the request
    var type: Type

    /// If true, the API will return clean text instead of HTML in all responses
    var clean: Boolean? = null

    /// An array of tiler value strings. These values can be used in filtering data in the action flow
    @SerialName("filter_values")
    var filterValues: List<String>? = null

    /// Itent Id to set conversation in a specific context
    @SerialName("context_intent_id")
    var contextIntentId: Int? = null

    /// Sets the Human Chat skill for the conversation
    var skill: String? = null

    /// The id of a button or a bot question
    var id: String? = null

    /// An string that is forwarded to External API's on each request
    @SerialName("custom_payload")
    var customPayload: String? = null

    /// Forwarded to the API Connector and External API's. This parameter can tell an API which timezone the client is currently in.
    /// The format is listed [here](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones).
    /// Use the column TZ database name from the list.
    @SerialName("client_timezone")
    var clientTimezone: String? = null
}

/**
Stopping a conversation

The STOP command will block the conversation. This is useful in authenticated conversation flows when you want
to force a new conversation to be created with the START command

{"command": "STOP", "conversation_id": String}
 */
@Serializable
class CommandStop : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null) {
        this.conversationId = conversationId
        this.userToken = userToken
    }

    @Required
    override var command = Command.STOP
}

/**
Use the CommandResume to list previous responses in a given conversation. When you resume a conversation,
you supply a conversation id

{"command": "RESUME", "clean": Boolean, "conversation_id": String}
 */
@Serializable
class CommandResume: IConversation {
    constructor(conversationId: String? = null,
                userToken: String? = null,
                skill: String? = null) {
        this.conversationId = conversationId
        this.userToken = userToken
        this.skill = skill
    }

    @Required
    override val command = Command.RESUME

    @Required
    var clean = false

    /// Sets the Human Chat skill for the conversation
    var skill: String? = null
}

/**
To delete a conversation, post a CommandDelete.

When you delete a conversation, the API will delete or overwrite:
- Message texts sent to and from the API
- Middle layer data created with API Connector
 */
@Serializable
class CommandDelete : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null) {
        this.conversationId = conversationId
        this.userToken = userToken
    }

    @Required
    override val command = Command.DELETE
}

/**
Poll for data

When the API returns poll=false or chat_status="virtual_agent", the conversation is in Virtual Agent mode.
When the API returns poll=true or chat_status="assigned_to_human" or chat_status="in_human_chat_queue"
the conversation is in Human Chat mode.

You can poll the server for more conversation data using the last known response id where response.source="bot".
Responses will contain any response with an Id larger then the supplied id. The maximum number of responses that
can be returned is 100

{"command": "POLL", "conversation_id": String, "clean": Boolean, "value: String}
 */
@Serializable
class CommandPoll : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null, value: String = "") {
        this.conversationId = conversationId
        this.userToken = userToken
        this.value = value
    }

    @Required
    override val command = Command.POLL

    /// html (false = default) or text (true) response
    @Required
    var clean = false

    /// Last known response Id
    @Required
    var value: String = ""
}

/**
Stop Human Chat

POLLSTOP will stop the Human Chat state and return the conversation to AI mode.

{"command": "POLLSTOP", "conversation_id": String}
 */
@Serializable
class CommandPollStop : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null) {
        this.conversationId = conversationId
        this.userToken = userToken
    }

    @Required
    override val command = Command.POLLSTOP
}

/**
Get a smart reply

Get a smart reply from the virtual agent when the conversation is in human chat mode

{"command": "SMARTREPLY", "conversation_id": String, "value": String}
 */
@Serializable
class CommandSmartReply : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null, value: String = "") {
        this.conversationId = conversationId
        this.userToken = userToken
        this.value = value
    }

    @Required
    override val command = Command.SMARTREPLY

    /// Message text
    var value: String = ""
}

/**
Post a human chat message

Send a message to the conversation from an external Human Chat system

{"command": "HUMANCHATPOST", "conversation_id", "value": String}
 */
@Serializable
class CommandHumanChatPost : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null, value: String = "") {
        this.conversationId = conversationId
        this.userToken = userToken
        this.value = value
    }

    @Required
    override val command = Command.HUMANCHATPOST

    /// Message text
    var value: String = ""
}

/**
User activity

When the user is typing, you might want to send a typing message to the server. If the conversation
router is in Human Chat mode, this will update the chat status in the Human Chat.

{"command": "TYPING", "conversation_id": String}
 */
@Serializable
class CommandTyping : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null) {
        this.conversationId = conversationId
        this.userToken = userToken
    }

    @Required
    override val command = Command.TYPING
}

/**
Feedback value

The rating parameter should be the integer 1 or 0. If the rating is missing, its value will be 0.
If you want your users to provide feedback in the form of text in addition to rating, use the text attribute
 */
@Serializable
data class CommandFeedbackValue (
    /// 1 or 0
    val rating: Int,

    /// Feedback text
    val text: String?,
)

/**
Conversation feedback

When a conversation ends, you might want to give the user the opportunity to give feedback on the conversation

{"command": "FEEDBACK", "conversation_id": String, "value": { "rating": Integer, "text": String}}
 */
@Serializable
class CommandFeedback : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null, value: CommandFeedbackValue) {
        this.conversationId = conversationId
        this.userToken = userToken
        this.value = value
    }

    @Required
    override val command = Command.FEEDBACK

    /// Feedback value
    lateinit var value: CommandFeedbackValue
}

/**
Download conversation history

Use this command to download a text version of a conversation. Either conversationId or userToken should be present in the payload

{"command": "DOWNLOAD", "conversation_id": String?, "user_token": String?}
 */
@Serializable
class CommandDownload : IConversation {
    constructor(conversationId: String? = null, userToken: String? = null) {
        this.conversationId = conversationId
        this.userToken = userToken
    }

    @Required
    override val command = Command.DOWNLOAD
}

class CommandLoginEvent : IConversation {
    constructor(conversationId: String? = null,
                userToken: String? = null,
                skill: String? = null,
    ) {
        this.conversationId = conversationId
        this.userToken = userToken
        this.skill
    }

    @Required
    override val command = Command.LOGINEVENT

    /// Sets the Human Chat skill for the conversation
    var skill: String? = null
}